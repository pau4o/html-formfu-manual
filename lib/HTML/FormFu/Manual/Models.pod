=pod

=head1 NAME

HTML::FormFu::Manual::Models - Interaction with data stores via models

=head1 INTRODUCTION

One of the most powerful features of L<HTML::FormFu> is its ability to integrate with various data models and automatically perform opearations with the form values, e.g. updating the corresponding database fields. In this chapter we will dissect how L<HTML::FormFu> models work and how you can use them to dramatically reduce the development time for you applications.

=head1 AVAILABLE MODELS

Currently there are two models available for use with L<HTML::FormFu>: L<HTML::FormFu::Model::HashRef>, which ships with the core L<HTML::FormFu> distribution, and L<HTML::FormFu::Model::DBIC>, which is a package which you need to install separately. L<HTML::FormFu::Model::HashRef> allows you to fill in forms from a hashref, or save form values to a hashref. It can be useful if you are interacting with a datastore that is not supported by L<HTML::FormFu> but can process data stored in hashrefs. L<HTML::FormFu::Model::DBIC> is a much more complicated modules which links L<HTML::FormFu> with the powerful L<DBIx::Class> library.

=head1 WORKING WITH MODELS - THE BASICS

Every L<HTML::FormFu> model class provides several important methods that add new functionality to your form object:

=over

=item default_values

This method is similar to the C<default_values> method of the base L<HTML::FormFu> class, but while the C<$form-E<gt>default_values> accepts as its argument a simple hash of field names and their respective values, C<$form-E<gt>model-E<gt>default_values> allows us to fill in a form with default values from arguments that are specific to every model class. For example, L<HTML::FormFu::Model::HashRef> fills in default values from a hashref, while L<HTML::FormFu::Model::DBIC> fills in default values from a C<DBIx::Class::Result> object. Internally, each model class converts the values of its argument into a simple hash and passes its values to C<default_values> in L<HTML::FormFu>.

=item create

The C<create> method creates a new record from the values of the filled form. In the L<HTML::FormFu::Model::HashRef>, it creates a new hashref, and in the case of L<HTML::FormFu::Model::DBIC> creates a new C<DBIx::Class::Result> object and inserts it into the databse.

  if ($form->submitted_and_valid)
  {
    # take the submitted values and create a new
	# record in the database ???
    $form->model->create({});
  }

=item update

C<update> is similar to C<create>, but it updates an existing record rather than creating a new one. With L<HTML::FormFu::Model::DBIC> you need to provide as an argument to update a valid C<DBIx::Class::Result> object, and its values in the database will be updated with the ones submitted from the form. You will normally use C<update> in conjunction with C<default_values>: 

  # fetch a record from the database
  my $record = $dbic_resultset->find({ id => 5 });

  # load the data from the record into the form
  $form->model->default_values($record);

  # later on in the script ....
  if ($form->submitted_and_valid)
  {
    # take the submitted values, update the record object
	# and save to database
    $form->model->update($record);
  }
  
Another common pattern is to invoke C<create> without any values to create an empty object and then work with it:

  # create a new record
  my $new_record = $dbic_resultset->create({});

  # the above is identical to:
  my $new_record = $form->model->create({});

  # load the data from the record into the form
  $form->model->default_values($new_record);

  # later on in the script ....
  if ($form->submitted_and_valid)
  {
    # take the submitted values, update the record object
	# and save to database
    $form->model->update($record);
  }

For L<HTML::FormFu::Model::HashRef>, both C<create> and C<update> perform exactly the same function, i.e. they return a hashref representing the new record.

=back

=head1 USING HTML::FORMFU::MODEL::DBIC

The rest of this chapter will focus exclusively on L<HTML::FormFu::Model::DBIC>, since this is the  more complex module and the one that you are most likely to need in your applications.

=head2 Loading and configuring the model class

Use C<model> to specify which model class you want to load:
  
  # loads HTML::FormFu::Model::DBIC
  $form->model('DBIC');

Normally your form will work with a particular DBIx::Class schema. You specify the name of that schema by putting a C<model> entry in the form's stash:

  my $schema = My::Schema::Class->connect( ... );
  $form->stash( schema => $schema );

If you are working with Catalyst, you can just supply the name of a Catalyst model instead:

  $form->stash( schema => 'Model::My::Schema::Class' );

Although a form is normally associated with a particular L<DBIx::Class> result class, you do not normally have to specify which class that is. Instead, you pass an object of that class as the argument to C<default_values>, C<create> or C<update>. L<HTML::FormFu> will work happiliy as long as you have given it an object which has columns and relationships corresponding to the ones you have specified in the form definition.

Most of the model configuration happens via the C<model_config> method of individual form elements. We will describe some of the most important options below.

=head2 Populating select fields

Before we move on to displaying and updating data from the database, we will discuss a very important topic - loading options for select fields from the database.

We have a C<Books> schema for a database containing information about books. One of the tables in the database - C<genre>, contains a list of genres that can be associated with books. Here is the result class for the C<genre> table:

  ### Books/Result/Genre.pm ###

  package Books::Result::Genre;

  use DBIx::Class::Candy;
  
  table 'genre';
  
  column 'id' => {
    data_type         => 'int',
    is_auto_increment => 1,
  };
  
  column 'name' => {
    data_type   => 'varchar',
  };
  
  primary_key 'id';
  
  1;
  
And here is the list of pre-defined genres that the C<genre> table contains:

  id  name
  --  -----------------
  1   Children's
  2   Fantasy
  3   Horror
  4   Mystery
  5   Romance
  6   Science Fiction
  7   Short Fiction
  8   Thriller/Suspense

When creating or editing a book record, we want to be able to choose from that list of genres. Normally we would do that by using either a select field or a group of radio buttons. We will create a script that builds that form and prints it out to STDOUT:

  use strict;
  use warnings;

  use HTML::FormFu;
  use Books;
  
  my $form = HTML::FormFu->new;
  
  # load configuration file
  $form->load_config_file("books.conf");
  
  # setup model and schema
  $form->model('DBIC');
  my $schema = Books->connect( ... );
  $form->stash( schema => $schema );

  $form->process;
  
  print $form->render;

We will start with the folowing configuration file (named C<books.conf>, in L<Config::General> format):

  <element>
    name name
    type Text
  </element>
  
  <element>
    name genre
    type Select
  </element>
  
  <element>
    name submit
    type Button
  </element>

Nothing surprising here, here is the output that we get when we render the form:

  <form action="" method="post">
    <div class="text">
      <input name="name" type="text" />
    </div>
    <div class="select">
      <select name="genre">
      </select>
    </div>
    <div class="button">
      <input name="submit" type="button" />
    </div>
  </form>

But if we change the definition of the C<author> field as follows:

  <element>
    name genre
    type Select
    <model_config>
      resultset Genre
    </model_config>
  </element>

we get all the options for the select field populated from the database:

  <form action="" method="post">
    <div class="text">
      <input name="name" type="text" />
    </div>
    <div class="select">
      <select name="genre">
        <option value="1">Children&#39;s</option>
        <option value="2">Fantasy</option>
        <option value="3">Horror</option>
        <option value="4">Mystery</option>
        <option value="5">Romance</option>
        <option value="6">Science Fiction</option>
        <option value="7">Short Fiction</option>
        <option value="8">Thriller/Suspense</option>
      </select>
    </div>
    <div class="button">
      <input name="submit" type="button" />
    </div>
  </form>

What happened here? As we said earlier, all options specific to the particular model we are using are specified in a C<model_config> hashref. In order for L<HTML::FormFu::Model::DBIC> to populate our select fields, several conditions need to be in place:

=over

=item *

The form element must inherit from L<HTML::FormFu::Element::_Group>, i.e. one of L<HTML::FormFu::Element::ComboBox>, L<HTML::FormFu::Element::Radiogroup>, L<HTML::FormFu::Element::Checkboxgroup> or L<HTML::FormFu::Element::Select>.

=item * 

The C<resultset> option must be passed to C<model_config>, so that L<HTML::FormFu::Model::DBIC> knows which result class to use to fetch the values. If C<resultset> does not contain any column (C<:>) characters, it will be expanded into a result class belonging to the loaded schema (i.e. C<Genre> will become C<Books::Result::Genre>). Otherwise it will be used as is.

If no resultset is specified, but C<model_config> is present, L<HTML::FormFu::Model::DBIC> will attempt to guess the result class from the name of the element. So, the following two element definitionss are equivalent:

  <element>
    name something
    type Select
    <model_config />
  </element>

  # is the same as:

  <element>
    name something
    type Select
    <model_config>
      resultset Something
    </model_config>
  </element>

=item *

And last, we may need to specify which colum to use as the value for each option, and which colum to use as the label. By default L<HTML::FormFu::Model::DBIC> uses the column holding the primary key as the value, and the first text column in the table as the label. You can override this behaviour with the C<id_column> and C<label_column> options respectively. The following definition of the select element achieves the same result as above, but is explicit about which columns to use for option values and labels:

  <element>
    name genre
    type Select
    <model_config>
      resultset Genre
	  id_column id
	  label_column name
    </model_config>
  </element>

=back

Let us say that at some point later a new requirement comes up that you must add non-fiction generes to the database, and you must be able to distinguish them from the fiction genres. We will add a boolean colum to specify whether a genre is fiction or not. The new C<genre> table will look like that:

  id  name                     fiction
  --  -----------------------  -------
  1   Children's               1
  2   Fantasy                  1
  3   Horror                   1
  4   Mystery                  1
  5   Romance                  1
  6   Science Fiction          1
  7   Short Fiction            1
  8   Thriller/Suspense        1
  9   Essay                    0
  10  Journal                  0
  11  History                  0
  12  Scientific Paper         0
  13  Biography                0
  14  Textbook                 0
  15  Travel Book              0
  16  Technical Documentation  0

And of course we add the new column in our C<Books::Result::Genre> class as well:

  package Books::Result::Genre

  ...

  column 'fiction' => {
    data_type => 'int',
	size      => 1,
  };

  ...

Now if we are required to create a form for editing non-fiction books, we may request that our select field be populated with only a subset of the rows in the C<genre> table. We change the definition of the select element as follows:

  <element>
    name genre
    type Select
    <model_config>
      resultset Genre
      <condition>
	    fiction 0
	  </condition>
    </model_config>
  </element>

This will produce the following form:

  <form action="" method="post">
    <div class="text">
      <input name="name" type="text" />
    </div>
    <div class="select">
      <select name="genre">
        <option value="9">Essay</option>
        <option value="10">Journal</option>
        <option value="11">History</option>
        <option value="12">Scientific Paper</option>
        <option value="13">Biography</option>
        <option value="14">Textbook</option>
        <option value="15">Travel Book</option>
        <option value="16">Technical Documentation</option>
      </select>
    </div>
    <div class="button">
      <input name="submit" type="button" />
    </div>
  </form>

Actually L<HTML::FormFu::Model::DBIC> has two complementary options that affect how rows are selected: C<condition> and C<attributes>. They are passed as the first and second argument to L<DBIx::Class::ResultSet::search> respectively. I.e. if you have the following C<model_config> specification for an element:

  <model_config>
    resultset SomeTable
    <condition>
	  ...
	</condition>
	<attributes>
	  ...
	</attributes>
  </model_config>

Assuming that the above definition is parsed into a C<$model_config> hashref, L<HTML::FormFu::Model::DBIC> will internally do something like this to fetch the rows containing the requested options:

  $schema->resultset( $model_config->resultset )->search( 
    $model_config->condition, 
	$model_config->attributes,
  );

=head2 Displaying and updating table fields

Now let us look at the most important part of working with models - automatically retrieving, displaying and updating data from the data store. The key link between fields in the database and fields in the form is the C<name> attribute (or C<nested_name> for Repeatable elements). In order to fill a form with data about a specific record from the database, you pass the record object to C<default_values>. In order to update a record, you pass the record object to the C<update> method.

Let us start with a simple book table. Here is the definition of the resultset object:

  ### Books/Result/Book.pm ###

  package Books::Result::Book;
  
  use DBIx::Class::Candy;
  
  table 'book';

  column 'id' => {
    data_type         => 'int',
    is_auto_increment => 1,
  };
  
  column 'title' => {
    data_type   => 'varchar',
  };
  
  column 'author' => {
    data_type   => 'varchar',
  };

  column 'publish_date' => {
    data_type   => 'date',
  };

  primary_key 'id';

  1;

The configuration file for a form to edit a book record may look like this:

  <element>
    name title
    type Text
	label "Title"
  </element>
  
  <element>
    name author
    type Text
	label "Author"
  </element>

  <element>
    name publish_date
    type Date
	label "Publish date"
  </element>

  <element>
    name submit
    type Button
  </element>

Now if we display the form and the user enters some values, we would need to do something like that to enter a new record in the database:

  ...
  if ($form->submitted_and_valid) {
  	my $result = $schema->resultset('Book')->create;
	$form->model->update($result);
  }

This creates a new empty record, and passes it to C<update>, which takes care of updating the record with the submitted values and saving it into the database. Here is how to go about editing an existing record:

  my $result = $schema->resultset('Book')->find({ id => $id });
  $form->model->default_values($result);

The form will be displayed with data from that record filled-in. After the form is submitted, updating the result object is as simple as:

  if ($form->submitted_and_valid) {
	$form->model->update($result);
  }

=head2 Displaying and updating fields from related tables

So far so good, but things become more complicated when a result object involves relationships between different tables. Let us expand on the topic of loading options from the database, and add updating to the mix. We will update our C<Book> class as follows, and the C<Books::Result::Genre> class will be identical to the one we used above:

  ### Books/Result/Book.pm ###

  package Books::Result::Book;
  
  use DBIx::Class::Candy;
  
  table 'book';

  ...

  column 'genre_id' => {
    data_type => 'int',
  };
  
  has_one 'genre' => ( 'Books::Result::Genre', 'genre_id' );

  primary_key 'id';

  1;

We will add a combobox to our form definition to select a genre.

  ...
  <element>
    name genre
    type Combobox
	label Genre
    <model_config>
      resultset Genre
    </model_config>
  </element>
  ...

You can use either C<genre>, or C<genre_id> as field name here. In the former case C<HTML::FormFu> will figure out that you want to update the C<genre> relationship and will know that it can do that by setting C<genre_id> in the C<book> table to the desired id. In the latter case it will just update C<genre_id> directly - in both cases the result will be the same. It is generally cleaner to use the name of the relationship as the C<name> attribute. For this to work, of course, we will have to use a form element that is based on L<HTML::FormFu::Element::_Group> and allows setting of a single option only, i.e.  L<HTML::FormFu::Element::Radiogroup>, L<HTML::FormFu::Element::Combobox> or L<HTML::FormFu::Element::Select> without the multiple attribute.

This becomes even more clear if we consider C<many_to_many> relationships. Let us say that some time after we have implemented our database, a new requirement comes up that more than one genre may be spefied for each book. To achieve that, we will need to add an intermediary table to keep track of the links between books and genres. We will have the following three table classes:

  ### Books/Result/Book.pm ###

  package Books::Result::Book;
  
  use DBIx::Class::Candy;
  
  table 'book';

  column 'id' ...
  
  column 'title' ...

  column 'author' ...

  column 'publish_date' ...

  many_to_many 'genres' => ( 'Books::Result::Genre', 'genre_id' );

  primary_key 'id';

  1;
  
  ### Books/Result/Genre.pm ###

  package Books::Result::Genre;

  use DBIx::Class::Candy;
  
  table 'genre';
  
  column 'id' ... 
  
  column 'name' ...
  
  primary_key 'id';
  
  many_to_many 'books' => ( 'Books::Result::Book', 'genre_id' );

  1;

  ### Books/Result/BookGenre.pm ###

  package Books::Result::BookGenre;

  use DBIx::Class::Candy;
  
  table 'book_genre';
  
  column 'book_id' => {
    data_type         => 'int',
  };
  
  column 'genre_id' => {
    data_type         => 'int',
  };
  
  primary_key 'book_id', 'genre_id';
  
  has_many 'books' => ( 'Books::Result::Book', 'book_id' );
  has_many 'genres' => ( 'Books::Result::Genre', 'genre_id' );

  1;

The only thing we need to do to make the new relationship work is to change the type of the form element to one that can accept multiple values (i.e. L<HTML::FormFu::Element::Checkboxgroup> or L<HTML::FormFu::Element::Select> with the multiple attribute set):

  ...
  <element>
    name genre
    type Select
	label Genre
	<attributes>
	  multiple 1
	</attributes>
    <model_config>
      resultset Genre
    </model_config>
  </element>
  ...

Now updating the result object will correctly set C<genre_id> and C<book_id> in table C<book_genre>.

=head2 Directly editing fields in related tables



=cut

